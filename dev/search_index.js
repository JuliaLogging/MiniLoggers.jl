var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MiniLoggers","category":"page"},{"location":"#MiniLoggers","page":"Home","title":"MiniLoggers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MiniLoggers]","category":"page"},{"location":"#MiniLoggers.MiniLogger-Tuple{}","page":"Home","title":"MiniLoggers.MiniLogger","text":"MiniLogger(; <keyword arguments>)\n\nMiniLogger constructor creates custom logger which can be used with usual @info, @debug commands.\n\nSupported keyword arguments include:\n\nio (default stdout): IO stream which is used to output log messages below errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nioerr (default stderr): IO stream which is used to output log messages above errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nerrlevel (default Error): determines which output IO to use for log messages. If you want for all messages to go to io, set this parameter to MiniLoggers.AboveMaxLevel. If you want for all messages to go to ioerr, set this parameter to MiniLoggers.BelowMinLevel.\nminlevel (default: Info): messages below this level are ignored. For example with default setting @debug \"foo\" is ignored.\nappend (default: false): defines whether to append to output stream or to truncate file initially. Used only if io or ioerr is a file path.\nsquash_message (default: true): if squash_message is set to true, then message is squashed to a single line, i.e. all \\n are changed to  and \\r are removed.\nflush (default: true): whether to flush IO stream for each log message. Flush behaviour also affected by flush_threshold argument.\nflush_threshold::Union{Integer, TimePeriod} (default: 0): if this argument is nonzero and flush is true, then io is flushed only once per flush_threshold milliseconds. I.e. if time between two consecutive log messages is less then flush_threshold, then second message is not flushed and will have to wait for the next log event.\ndtformat (default: \"yyyy-mm-dd HH:MM:SS\"): if datetime parameter is used in format argument, this dateformat is applied for output timestamps.\nformat (default: \"{[{datetime}]:func} {message}\"): format for output log message. It accepts following keywords, which should be provided in curly brackets:\ndatetime: timestamp of the log message\nlevel: name of log level (Debug, Info, etc)\nfilepath: filepath of the file, which produced log message\nbasename: basename of the filepath of the file, which produced log message\nline: line number of the log command in the file, which produced log message\ngroup: log group \nmodule: name of the module, which contains log command\nid: log message id\nmessage: message itself\n\nEach keyword accepts color information, which should be added after colon inside curly brackets. Colors can be either from Base.text_colors or special keyword func, in which case is used automated coloring. Additionaly, bold modifier is accepted by the format argument. For example: {line:red}, {module:cyan:bold}, {group:func} are all valid parts of the format command.\n\nColour information is applied recursively without override, so {{line} {module:cyan} {group}:red} is equivalent to {line:red} {module:cyan} {group:red}.\n\nIf part of the format is not a recognised keyword, then it is just used as is, for example {foo:red} means that output log message contain word \"foo\" printed in red.\n\n\n\n\n\n","category":"method"}]
}
